

from typing import  Sequence, List

from langchain_core.messages import BaseMessage, HumanMessage, SystemMessage
from langgraph.graph import END, START, StateGraph
from langgraph.graph.message import add_messages
from typing_extensions import Annotated, TypedDict

from src.modules.tools.data_objects import ProcessedCommand, VerificationResult


class VerificationInputState(TypedDict):
    messages: Annotated[Sequence[BaseMessage], add_messages]


class VerificationOutputState(TypedDict):
    verification_result: VerificationResult


class VerificationAgentState(VerificationInputState, VerificationOutputState):
    pass


class VerificationTool:

    VERIFICATION_PROMPT = """
    You are a diagnostic verification engine. Your task is to analyze the diagnostic results generated by a sysadmin expert and produce a structured decision.

    You are given four input tags:
    <objectives>: Describe your main goals.
    <incident_description>: Describes the reported issues or symptoms observed.
    <runtime_description>: Describes the current runtime environment or context.
    <diagnostic_commands>: A list of diagnostic commands that were executed to diagnose the incident.
    <output_format>: Instructions or constraints that must be followed when suggesting new commands.
    <examples>: Some examples of commands that can be executed to diagnose the incident.

    <objectives>
    1. Based on the diagnosis results, determine one of the following verdicts:
    - "CONFIRMED": The problem as stated in the incident description is confirmed and remediation might be needed.
    - "FALSE_POSITIVE": The problem as stated in the incident description is not confirmed and the remediation might not be needed.
    - "INCONCLUSIVE": The issue cannot be diagnosed with the available information, more information is needed. Use this option only if you really cannot confirm the problem or mark it as FALSE_POSITIVE.
    2. When making a decision, your explanation must explicitly state the root cause with maximum clarity and include technical detail, such as:
    - Process-based causes: State the process name, PID, resource usage, user running it.
    - Service-related causes: State service name, port, logs if available.
    - File-based causes: State file name, absolute path, permission/state.
    - User-based causes: State user, group, login activity.
    - Kernel issues: State kernel module, version, or logs.
    - Hardware issues: State hardware component, failure status, driver/module.
    - Network issues: State IP, port, protocol, failed connections or high latency.
    - Software issues: State software name, version, error logs or behavior.
    - Configuration issues: State config file, key, and problematic value.
    - Other causes: State the category and describe it thoroughly.
    3. If no conclusive root cause can be determined from the data, mark it "INCONCLUSIVE" and explain whatâ€™s missing and what additional information would be required. Some diagnostic commands might fail or provide no useful information, which may be the reason of inconclusive result.
    4. Do not speculate. Only base your reasoning on what is present in the diagnostic data.
    </objectives>

    <output_format>
    {
        "verdict": "CONFIRMED" | "FALSE_POSITIVE" | "INCONCLUSIVE",
        "explanation": "Short summary of the finding",
        "detailed_explanation": "Deep dive explanation including what caused the issue, how it was diagnosed, relevant logs, process IDs, commands run, and the conclusion drawn from the diagnostic data."
    }
    </output_format>

    <examples>
    Example 1:
    {
        "verdict": "CONFIRMED",
        "explanation": "The problem stated in the incident description is confirmed and remediation might be needed.",
        "detailed_explanation": "The load average is high, which indicates that the system is under heavy load. The top processes are using 100% of CPU, which is causing the issue. The process is stress-ng with PID 345, which is running on the system. The diagnostic commands were: ps aux | grep stress-ng, top, and dmesg | grep -i cpu. The interpretation summary is: The system is under heavy load due to stress-ng process with PID 345."
    }

    Example 2:
    {
        "verdict": "FALSE_POSITIVE",
        "explanation": "The problem stated in the incident description is not confirmed and the remediation might not be needed.",
        "detailed_explanation": "The load average is low, which indicates that the system is not under heavy load, which contradicts the incident description. The top processes are using 10% of CPU, which is not alarming. The diagnostic commands were: ps aux | grep stress-ng, top, and dmesg | grep -i cpu. The interpretation summary is: The system is not under any load."
    }

    Example 3:
    {
        "verdict": "INCONCLUSIVE",
        "explanation": "The issue cannot be diagnosed with the available information, more information is needed.",
        "detailed_explanation": "The diagnostic commands were: ps aux | grep stress-ng, top, and dmesg | grep -i cpu. Most of the commands failed or provided no useful information, which is the reason of inconclusive result."
    }
    </examples>

    Do not rush with a solution. Take your time and think step by step.
    """

    def __init__(self, llm, prompt=VERIFICATION_PROMPT):
        self.llm = llm.with_structured_output(
            VerificationResult, method="function_calling"
        )
        self.prompt = prompt
        self.graph = self._build()

    def _build(self):
        graph_builder = StateGraph(
            VerificationAgentState,
            input=VerificationInputState,
            output=VerificationOutputState,
        )

        def verification(state):
            return {"verification_result": self.llm.invoke(state["messages"])}

        graph_builder.add_node("verification", verification)
        graph_builder.add_edge(START, "verification")
        graph_builder.add_edge("verification", END)

        return graph_builder.compile()

    def run(
        self,
        incident_description: str,
        environment_description: str,
        diagnostic_commands: List[ProcessedCommand] = [],
    ):

        input_data = "Verify the following incident:\n"
        input_data += (
            f"<incident_description>{incident_description}</incident_description>\n"
        )
        input_data += (
            f"<runtime_description>{environment_description}</runtime_description>\n"
        )
        input_data += (
            f"<diagnostic_commands>{diagnostic_commands}</diagnostic_commands>"
        )

        inputs = {
            "messages": [
                SystemMessage(content=self.prompt),
                HumanMessage(content=input_data),
            ]
        }
        output = self.graph.invoke(inputs)["verification_result"]
        return output